◆ 기본적인 정렬 알고리즘

정렬 알고리즘의 종류

	simple, slow
	- Bubble sort
	- Insertion sort
	- Selection sort
	
	fast
	- Quicksort
	- Merge sort
	- Heap sort
	
	O(N)
	- Radix sort

-----------------------------------
Selection sort

* 이미지 참고 : SelectionSort.PNG

각 루프마다
	최대 원소를 찾는다.
	최대 원소와 맨 오른쪽 원소를 교환한다.
	맨 오른쪽 원소를 제외한다.
	
하나의 원소만 남을 때까지 위의 루프를 반복

	-----------
	Pseudo-code

selectionSort(A[], n) -> 배열[1...n]을 정렬한다.
{
	for last <- n downto 2 { ------------- 1
		A[1...last] 중 가장 큰 수 A[k]를 찾는다; ------------- 2
		A[k] <-> A[last]; A[k]와 A[last]의 값을 교환 --------------- 3
	}
}

수행시간 : 
	1의 for 루프는 n-1번 반복
	2에서 가장 큰 수를 찾기 위한 비교횟수 : n-1, n-2,...,2,1
	3의 교환은 상수시간 작업
시간복잡도 T(n)=(n-1) + (n-2) + .... + 2 + 1 = O(n²)
		 
-----------------------------------
Bubble sort
 
* 이미지 참고 : BubbleSort.PNG

	-----------
	Pseudo Code
	
bubbleSort(A[], n) 배열 A[1...n]을 정렬한다.
{
	for last <- n downto 2 { -------------- 1
		for i <- 1 to last-1 --------------- 2
			if(A[i]> A[i+1]) then A[i] <-> A[i+1]; 교환 -------- 3
}

수행시간 : 
	1의 루프는 n-1번 반복
	2의 for 루프는 각각 n-1, n-2, .... + 2 + 1번 반복
	3의 교환은 상수시간 작업
T(n) = (n-1) + (n-2) + .... + 2 + 1 = O(n²)

-----------------------------------
Insertion sort
 
* 이미지 참고 : InsertionSort.PNG

	-----------
	Pseudo Code
	
insertionSort(A[],n) -> 배열 A[1...n]을 정렬한다.
{
	for i <- 2 to n { ----------- 1
		A[1...i]의 적당한 자리에 A[i]를 삽입한다. ------------- 2
}

수행시간 : 
	1의 for 루프는 n-1번 반복
	2의 삽입은 최악의 경우 i-1번 비교
최악의 경우 : T(n) = (n-1) + (n-2) + ... + 2 + 1 = O(n²)

================================================================================================================================
◆ 합병정렬(merge sort)

	
================================================================================================================================
